# Typescript 泛型 `<>`

----

*泛型是为了提高代码的重用性和代码的通用性*

> ## 使用泛型

泛型其实是将一种或者多种类型提升，并且用一个自定义的标识符用来表示，比如现在要提升一个函数的参数类型，该参数类型可以是任意值，并且返回的是与其一样的类型

```typescript
//比如现在有个需求是传入任何值，就返回该值，讲道理传入任意类型，返回的都是其对应的相同类型
//但是这个例子，是将任意类型的值返回原来的数值，其返回值也是一个任意类型
function identity(arg: any): any {
    return arg;
}

//那我们在调用函数的返回值的类型的时候，将会拿到一个any类型的数据，ts不会自动去转换为string类型，因为
let output = identity("myString");  // type of output will be 'string'



//泛型的用法如下
function identity<T>(arg:any): T{
    return arg
}

```

> ## 将泛型当作变量

比如现在有一个返回该类型的一个数组，则泛型应该表示该数组所有元素的类型，实现如下：

```typescript
function identity2<T>(arg:T[]):T[]{
    //这里是将函数参数的所有元素的类型提升为泛型，并且将泛型作为返回数组的类型
    console.log(arg.length)
    return arg
}
```

> ## 泛型也是一个类型

泛型也是一种类型，泛型本身也可以有接口和类

泛型接口，就是对一类泛型的提升，比如刚刚的传入和传出值相同时场景，泛型用来表示传入和传出值的任意类型

就能把这种抽象为一种泛型接口

```typescript

interface argToResult {
    <T>(arg:T):T;
}
// 这样表示一类泛型，都是输入和输出相同的这一类泛型

// 使用方法如下：

// 如果有一个新的函数，也需要这种泛型

function identity1<T>(arg:T):T{
    console.log(arg.length);
    return arg
}

let indentity2: argToResult<number> = identity1;
//这句话表示identity2引用argToResult泛型接口，其参数的类型也将和返回值一样，并且传入了一个number表示指定类型的泛型

```
> ## 泛型类

泛型既然也是一种类型，那也可以创建泛型类

```typescript

class GenericNumber<T> {
    zeroValue: T;
    add: (x: T, y: T) => T;
}

let myGenericNumber = new GenericNumber<number>();
myGenericNumber.zeroValue = 0;
myGenericNumber.add = function(x, y) { return x + y; };
```

> ## 泛型继承接口，实现泛型的约束

例如现在要实现一个通用类型（有length方法的所有）的函数，打印其的length值并返回其本身，由于不知道其参数类型，可以指定其为泛型

```typescript
function returnLength<T>(arg:T):T{
    console.log(arg.length)
    return arg
}
//但是这样并不能保证所有的参数都有length这个方法，于是需要对泛型进行限制，增加接口

interface lengthRequire{
    length:number//表示其length属性必须为数值型
}

function newReturnLength<T extend lengthRequire>(arg:T):T{
    console.log(arg.length)
    return arg
}
//这样在函数调用的时候就绝对不会报错
//但是没有length属性的参数将会在函数之前直接编译无法通过
```

